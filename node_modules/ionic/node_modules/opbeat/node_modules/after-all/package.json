{
  "name": "after-all",
  "version": "2.0.1",
  "description": "Execute several async functions and get a callback when they are all done",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sorribas/after-all.git"
  },
  "scripts": {
    "test": "tape test"
  },
  "author": {
    "name": "Eduardo Sorribas",
    "email": "eduardo@sorribas.org",
    "url": "http://sorribas.org/"
  },
  "license": "MIT",
  "devDependencies": {
    "tape": "^2.13.3"
  },
  "dependencies": {
    "once": "^1.3.0"
  },
  "testling": {
    "files": "test/index.js",
    "browsers": [
      "ie/8..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# after-all\n\n[![build status](https://secure.travis-ci.org/sorribas/after-all.png)](http://travis-ci.org/sorribas/after-all)\n\nCall several asynchronous functions and invoke a callback 'after all' of them are done.\n\n## Installation\n\nYou can install it with npm.\n\n```\nnpm install after-all\n```\n\n## Simple example\n\n```js\nvar afterAll = require('after-all');\nvar next = afterAll(done);\n\nsetTimeout(next(function() {\n  console.log('Step two.');\n}), 500);\n\nsetTimeout(next(function() {\n  console.log('Step one.');\n}), 100);\n\nfunction done() {\n  console.log(\"Yay we're done!\");\n}\n```\n\n## More complex example and sample use case\n\nImagine you have to create a dashboard page which has a list of customers\na list products, the total amount of sales and some more information.\n\nNow, the queries to get this information are independent, yet we tend to wait for\none to be finished to start the next. We may be able to increase the performance\nby starting some of this queries at the same time and waiting for the callbacks.\n\nWe can use after-all to do something like this.\n\n```js\n\napp.get('/dashboard.json', function(req, res) {\n  var resp = {};\n  var next = afterAll(function() {\n    res.end(resp);\n  });\n\n  db.findCustomers(next(function(err, docs) {\n    resp.customers = docs;\n  }));\n\n  var cb = next(); // wrapping the callback is optional\n  db.findProducts(function(err, docs) {\n    db.findProductsSales(function(sales) {\n      resp.products = docs;\n      resp.productsSales = sales;\n      cb();\n    });\n  });\n\n  db.findTodaySalesAmount(next(function(err, amount) {\n    resp.todaySales = amount;\n  }));\n\n  db.findLastMonthSalesAmount(next(function(err, amount) {\n    resp.lastMonthSales = amount;\n  }));\n});\n```\n\nAs you can see, passing a callback to the `next` function is optional and it can be\nuseful to not pass any when you are doing more than one sequetial async operations as\nin the example above.\n\nAlso notice that all the calls to `next` must be done on the same tick.\n\n## Error handling\n\nIf an error is passed as the first parameter to the `next` callback, the \nfinal callback will be called immediately and the error will be passed to\nit as the first argument.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/sorribas/after-all/issues"
  },
  "homepage": "https://github.com/sorribas/after-all",
  "_id": "after-all@2.0.1",
  "_shasum": "d6f81e15b3211990a5fc268715291f2e0be507e5",
  "_resolved": "https://registry.npmjs.org/after-all/-/after-all-2.0.1.tgz",
  "_from": "https://registry.npmjs.org/after-all/-/after-all-2.0.1.tgz"
}
